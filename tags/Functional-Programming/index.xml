<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Functional Programming on Dr Random</title><link>http://drrandom.org/tags/Functional-Programming/</link><description>Recent content in Functional Programming on Dr Random</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 14 Jun 2015 21:09:13 +0000</lastBuildDate><atom:link href="http://drrandom.org/tags/Functional-Programming/index.xml" rel="self" type="application/rss+xml"/><item><title>A bit on making functions tail-recursive in F#</title><link>http://drrandom.org/2015/06/14/a-bit-on-making-functions-tail-recursive-in-f/</link><pubDate>Sun, 14 Jun 2015 21:09:13 +0000</pubDate><guid>http://drrandom.org/2015/06/14/a-bit-on-making-functions-tail-recursive-in-f/</guid><description>If you recall a while back when I was demonstrating some Functional Data Structures , I mentioned the fact that some of the functions were not tail recursive, and that this is something that we would probably want to do something about. Which raises the question: How exactly do we go about making a function tail-recursive? I am going to attempt to address that question here.
One of the first problems with creating a tail recursive function is figuring out whether a function is tail recursive in the first place.</description></item><item><title>fold – The greatest thing that ever happened to your data structure</title><link>http://drrandom.org/2015/06/08/purely-functional-data-structures-part-2/</link><pubDate>Mon, 08 Jun 2015 17:16:22 +0000</pubDate><guid>http://drrandom.org/2015/06/08/purely-functional-data-structures-part-2/</guid><description>Let&amp;rsquo;s say that you’ve been working hard on this really awesome data structure. Its fast, its space efficient, its immutable, its everything anyone could dream of in a data structure. But you only have time to implement one function for processing the data in your new miracle structure, so what would it be?
Ok, not a terribly realistic scenario, but bare with me here, there is a point to this. The answer to this question, of course, is that you would implement fold.</description></item><item><title>Purely Functional Data Structures–Part 2</title><link>http://drrandom.org/2012/07/24/purely-functional-data-structures-part-2/</link><pubDate>Tue, 24 Jul 2012 18:15:17 +0000</pubDate><guid>http://drrandom.org/2012/07/24/purely-functional-data-structures-part-2/</guid><description>So here we are at part 2 in the series of posts looking at Functional Data Structures from the book of the same name by Chris Okasaki. Last time we looked at what is perhaps the simplest of the functional data structures, the List (also useful as a LIFO stack). Up next we’ll continue in the order that Chris Okasaki used in his book, and take a look at implementing a Set using a Binary Tree.</description></item><item><title>Purely Functional Data Structures–Part 1</title><link>http://drrandom.org/2012/07/23/purely-functional-data-structures-part-1/</link><pubDate>Mon, 23 Jul 2012 06:00:00 +0000</pubDate><guid>http://drrandom.org/2012/07/23/purely-functional-data-structures-part-1/</guid><description>I thought it might be fun to explore a little bit of CS as it applies to functional programming, by looking at the idea of Functional Data Structures. This is actually an area that is still getting a lot of active research, and is pretty interesting stuff overall. The general idea is to try and figure out ways to provide immutable data structures which can be efficiently implemented in a functional setting.</description></item><item><title>A quick (?) retrospective on learning (and using) F#</title><link>http://drrandom.org/2012/07/22/a-quick-retrospective-on-learning-and-using-f/</link><pubDate>Sun, 22 Jul 2012 15:00:00 +0000</pubDate><guid>http://drrandom.org/2012/07/22/a-quick-retrospective-on-learning-and-using-f/</guid><description>As you may have guessed from the title, I’ve started doing some work with F#. Initially I was somewhat reluctant to go down the F# path because some of the more interesting aspects of the other functional languages I’ve been exploring are not present…specifically the type systems behind Scala and Haskell, the laziness of Haskell, and the concurrent programming model of Erlang. In spite of these perceived downfalls, there were some definite plusses, namely interoperability with everything .</description></item><item><title>I think Scala may be a gateway drug</title><link>http://drrandom.org/2012/01/24/i-think-scala-may-be-a-gateway-drug/</link><pubDate>Tue, 24 Jan 2012 06:52:00 +0000</pubDate><guid>http://drrandom.org/2012/01/24/i-think-scala-may-be-a-gateway-drug/</guid><description>As I have been trying to learn more about Scala, there have been several paths that I’ve had to follow. One is getting acquainted with the state of Java development, since ultimately Scala exists within the Java ecosystem. Another is finding my way around the Scala libraries, tools, and idioms. But there is a third that seems to be somewhat deeper, and that is coming to grips with the functional nature of the language.</description></item><item><title>Making the Climb Part 4–Pattern Matching</title><link>http://drrandom.org/2012/01/22/making-the-climb-part-4-pattern-matching/</link><pubDate>Sun, 22 Jan 2012 20:23:58 +0000</pubDate><guid>http://drrandom.org/2012/01/22/making-the-climb-part-4-pattern-matching/</guid><description>Continuing our journey down the path from the familiar to the down-right bizarre, we find ourselves at Pattern Matching. This is a feature of the Scala language that shows it’s functional side in a strong way. Pattern Matching is a fundamental part of functional languages in general, and provides a way to write very concise and expressive code. On the surface, pattern matching in Scala looks an awful lot like switch statements in C# (and Java for that matter), but you shouldn’t cling too hard to that association.</description></item></channel></rss>