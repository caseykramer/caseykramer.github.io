<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>F# on Dr Random</title><link>http://drrandom.org/tags/F#/</link><description>Recent content in F# on Dr Random</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 14 Jun 2015 21:09:13 +0000</lastBuildDate><atom:link href="http://drrandom.org/tags/F#/index.xml" rel="self" type="application/rss+xml"/><item><title>A bit on making functions tail-recursive in F#</title><link>http://drrandom.org/2015/06/14/a-bit-on-making-functions-tail-recursive-in-f/</link><pubDate>Sun, 14 Jun 2015 21:09:13 +0000</pubDate><guid>http://drrandom.org/2015/06/14/a-bit-on-making-functions-tail-recursive-in-f/</guid><description>If you recall a while back when I was demonstrating some Functional Data Structures , I mentioned the fact that some of the functions were not tail recursive, and that this is something that we would probably want to do something about. Which raises the question: How exactly do we go about making a function tail-recursive? I am going to attempt to address that question here.
One of the first problems with creating a tail recursive function is figuring out whether a function is tail recursive in the first place.</description></item><item><title>fold – The greatest thing that ever happened to your data structure</title><link>http://drrandom.org/2015/06/08/purely-functional-data-structures-part-2/</link><pubDate>Mon, 08 Jun 2015 17:16:22 +0000</pubDate><guid>http://drrandom.org/2015/06/08/purely-functional-data-structures-part-2/</guid><description>Let&amp;rsquo;s say that you’ve been working hard on this really awesome data structure. Its fast, its space efficient, its immutable, its everything anyone could dream of in a data structure. But you only have time to implement one function for processing the data in your new miracle structure, so what would it be?
Ok, not a terribly realistic scenario, but bare with me here, there is a point to this. The answer to this question, of course, is that you would implement fold.</description></item><item><title>Purely Functional Data Structures–Part 2</title><link>http://drrandom.org/2012/07/24/purely-functional-data-structures-part-2/</link><pubDate>Tue, 24 Jul 2012 18:15:17 +0000</pubDate><guid>http://drrandom.org/2012/07/24/purely-functional-data-structures-part-2/</guid><description>So here we are at part 2 in the series of posts looking at Functional Data Structures from the book of the same name by Chris Okasaki. Last time we looked at what is perhaps the simplest of the functional data structures, the List (also useful as a LIFO stack). Up next we’ll continue in the order that Chris Okasaki used in his book, and take a look at implementing a Set using a Binary Tree.</description></item><item><title>Purely Functional Data Structures–Part 1</title><link>http://drrandom.org/2012/07/23/purely-functional-data-structures-part-1/</link><pubDate>Mon, 23 Jul 2012 06:00:00 +0000</pubDate><guid>http://drrandom.org/2012/07/23/purely-functional-data-structures-part-1/</guid><description>I thought it might be fun to explore a little bit of CS as it applies to functional programming, by looking at the idea of Functional Data Structures. This is actually an area that is still getting a lot of active research, and is pretty interesting stuff overall. The general idea is to try and figure out ways to provide immutable data structures which can be efficiently implemented in a functional setting.</description></item><item><title>A quick (?) retrospective on learning (and using) F#</title><link>http://drrandom.org/2012/07/22/a-quick-retrospective-on-learning-and-using-f/</link><pubDate>Sun, 22 Jul 2012 15:00:00 +0000</pubDate><guid>http://drrandom.org/2012/07/22/a-quick-retrospective-on-learning-and-using-f/</guid><description>As you may have guessed from the title, I’ve started doing some work with F#. Initially I was somewhat reluctant to go down the F# path because some of the more interesting aspects of the other functional languages I’ve been exploring are not present…specifically the type systems behind Scala and Haskell, the laziness of Haskell, and the concurrent programming model of Erlang. In spite of these perceived downfalls, there were some definite plusses, namely interoperability with everything .</description></item></channel></rss>